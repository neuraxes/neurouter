// Copyright 2024 Neurouter Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package neurouter.v1;

option go_package = "github.com/neuraxes/neurouter/api/neurouter/v1;v1";

message GenerationConfig {
  // The maximum number of tokens that can be generated.
  optional int64 max_tokens = 1;
  // The temperature sampling. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
  optional float temperature = 2;
  // The nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
  optional float top_p = 3;
  // The top_k sampling, where the model considers the results of the top_k most probable tokens.
  optional int64 top_k = 4;
  // Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
  optional float frequency_penalty = 5;
  // Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
  optional float presence_penalty = 6;

  oneof template {
    string preset_template = 50;
  }

  oneof grammar {
    // Preset grammars, e.g. "text", "json_object", etc.
    string preset_grammar = 60;
    // The GGML BNF grammar definition.
    string gbnf_grammar = 61;
    // The JSON schema definition.
    string json_schema = 62;
  }
}

message Statistics {
  message Usage {
    uint32 input_tokens = 1;
    uint32 output_tokens = 2;
    uint32 cached_input_tokens = 3;
  }

  Usage usage = 1;
}

// Modality defines the types of input/output the model can handle.
enum Modality {
  MODALITY_UNSPECIFIED = 0;
  MODALITY_TEXT = 1;
  MODALITY_IMAGE = 2;
  MODALITY_AUDIO = 3;
  MODALITY_VIDEO = 4;
}

// Capability defines what the model can do.
enum Capability {
  CAPABILITY_UNSPECIFIED = 0;
  CAPABILITY_CHAT = 1;
  CAPABILITY_COMPLETION = 2;
  CAPABILITY_EMBEDDING = 3;
  CAPABILITY_TOOL_USE = 4;
}

message Schema {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_STRING = 1;
    TYPE_NUMBER = 2;
    TYPE_INTEGER = 3;
    TYPE_BOOLEAN = 4;
    TYPE_ARRAY = 5;
    TYPE_OBJECT = 6;
  }

  Type type = 1;
  string description = 2;
  Schema items = 3;
  map<string, Schema> properties = 4;
  repeated string required = 5;
  repeated string enum = 6;
}

message Tool {
  message Function {
    string name = 1;
    string description = 2;
    Schema parameters = 3;
  }

  oneof tool {
    Function function = 1;
  }
}